# DirectX Tutorial Explanation

## Tutorial 02

> This application displays a triangle using Direct3D 11

## 1. Peek Message & Get message

Peek Message 함수는 Message 가 있을 경우에는 true 를 반환하고, 그렇지 않을 경우에는 false 를 반환한다.

그러나 Get Message 함수의 경우에는 Message 가 없을 경우, Message 가 생길 때까지 기다린다. 

사용자가 입력을 주기 전까지 가만히 있는 게임을 사람들이 원하지는 않는다. 즉, 게임의 경우에는 Peek Message 를 사용해야 한다.

    // Main message loop
    MSG msg = {0};
    while( WM_QUIT != msg.message )
    {
        // peek -> 쓱 본다. 메시지가 있나 없나. 메시지가 없더라도 block에 걸리지 않는다.
        // get -> 가져온다. 메시지가 있으면 가져오고, 없으면 block
        if( PeekMessage( &msg, nullptr, 0, 0, PM_REMOVE ) )     // 메시지가 있냐?
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
        else                                                    // 메시지가 없냐?
        {
            Render();
        }
    }

Quit Message가 들어오지 않는 동안, 게임 Loop는 계속 돌아간다.

## 2. Macro

몇 가지 Macro 함수가 있다. 

    if( FAILED( InitWindow( hInstance, nCmdShow ) ) )
        return 0;

    if( FAILED( InitDevice() ) )
    {
        CleanupDevice();
        return 0;
    }

위 코드를 보면 FAILED 라는 Macro 함수가 있다. 

이는 내부에서 실행된 값이 무엇이냐에 따라 실행되며, 위 코드의 경우에는 FAILED 가 통과되면 프로그램이 종료된다. 

추가로 FAILED의 파라메터는 HRESULT다.

## 3. Device

Device는 DirectX의 몸체라고 생각하면 된다. Device에 관한 다양한 함수가 있다.

### InitDevice()

    HRESULT InitDevice()

InitDevice() 함수의 경우에는 Device의 초기값을 설정하는 함수다.
반환 값은 위에도 나왔던 HRESULT다.

    RECT rc;
    GetClientRect( g_hWnd, &rc );
    UINT width = rc.right - rc.left;
    UINT height = rc.bottom - rc.top;

InitDevice() 함수를 보면 이런 방법을 이용해 윈도우 사이즈를 rc 라는 변수에 저장한다.

좌표계는 좌상단 기준이다.

        UINT createDeviceFlags = 0;
    #ifdef _DEBUG
        createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;

이는 DirectX를 Debug 모드로 바꾸겠다는 뜻이다. 게임을 개발 할 때, 문제점을 찾기 위해 사용한다고 함.

    D3D_DRIVER_TYPE driverTypes[] =
    {
        D3D_DRIVER_TYPE_HARDWARE,
        D3D_DRIVER_TYPE_WARP,
        D3D_DRIVER_TYPE_REFERENCE,
    };

REFERENCE 는 100 퍼센트 소프트웨어 기반으로 작동하는 Driver Type 이다. 
즉, 매우 느리다. 
그러나 GPU 가 없는 장치에서도 돌아간다. 

WARP 같은 경우에는 CPU 기반으로 돌아가는 놈이다.

HARDWARE의 경우에는 100 퍼센트 GPU 기반으로 돌아가는 놈으로 당연히 제일 빠르다.

    D3D_FEATURE_LEVEL featureLevels[] =
    {
        D3D_FEATURE_LEVEL_11_1,
        D3D_FEATURE_LEVEL_11_0,
        D3D_FEATURE_LEVEL_10_1,
        D3D_FEATURE_LEVEL_10_0,
    };

이는 feature level 을 검사하기 위함 친구다. 
최우선 적으로 11.1 이 있는지를 확인하고 순차적으로 낮은 단계의 level 을 찾는다.

> ??? : 이것도 없어...? 그럼 이거는... 어? 이것도 없네.

    DXGI_SWAP_CHAIN_DESC1 sd = {};
    sd.Width = width;
    sd.Height = height;
    sd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.BufferCount = 1;

Swap Chain 이란 사용자에게 프레임을 표시하기 위한 버퍼 컬렉션이다. 
새 프레임을 표시 하려고 할 때마다, Sawp Chain 의 첫 번째 버퍼가 화면에 표시된 버퍼를 대신한다.
이러한 프로세스를 교환 혹은 대칭 이동이라 한다.

    // Create a render target view
    ID3D11Texture2D* pBackBuffer = nullptr;
    hr = g_pSwapChain->GetBuffer( 0, __uuidof( ID3D11Texture2D ), reinterpret_cast<void**>( &pBackBuffer ) );
    if( FAILED( hr ) )
        return hr;

화면에 texture를 그리기 위해서는 render target view, 읽으려고 한다면 shader resource view 를 이용한다고 한다. 

이 이야기를 한 이유는, 위에서 Swap Chain 이 가지고 있는 buffer를 가지고 오는데 이는 back buffer 다. 
이 buffer 에는 기본 texture 가 들어 있는데 이것의 type 은 ID3D11Texture2D 이다.
이제 이를 담아서 hr 에 전달하고 실패하면 탈출한다.

이외에도 hr 에 관한 부분이 많은데 너무 많으니 몇 개는 패스.

나머지는 내일...